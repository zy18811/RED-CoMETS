"""
SAX implmentation modified from https://github.com/seninp/saxpy
"""
import numpy as np
from numba import njit

@njit
def idx2letter(idx):
    """Convert a numerical index to a char."""
    if 0 <= idx < 26:
        return chr(97 + idx)
    else:
        raise ValueError('A wrong idx value supplied.')

@njit(parallel = True)
def znorm(series, znorm_threshold=0.01):
    """Znorm implementation."""
    sd = np.std(series)
    if (sd < znorm_threshold):
        return series
    mean = np.mean(series)
    return (series - mean) / sd

@njit
def cuts_for_asize(a_size):
    """Generate a set of alphabet cuts for its size."""
    """ Typically, we generate cuts in R as follows:
        get_cuts_for_num <- function(num) {
        cuts = c(-Inf)
        for (i in 1:(num-1)) {
            cuts = c(cuts, qnorm(i * 1/num))
            }
            cuts
        }

        get_cuts_for_num(3) """
    options = {
        2: np.array([-np.inf,  0.00]),
        3: np.array([-np.inf, -0.4307273, 0.4307273]),
        4: np.array([-np.inf, -0.6744898, 0, 0.6744898]),
        5: np.array([-np.inf, -0.841621233572914, -0.2533471031358,
                    0.2533471031358, 0.841621233572914]),
        6: np.array([-np.inf, -0.967421566101701, -0.430727299295457, 0,
                    0.430727299295457, 0.967421566101701]),
        7: np.array([-np.inf, -1.06757052387814, -0.565948821932863,
                    -0.180012369792705, 0.180012369792705, 0.565948821932863,
                    1.06757052387814]),
        8: np.array([-np.inf, -1.15034938037601, -0.674489750196082,
                    -0.318639363964375, 0, 0.318639363964375,
                    0.674489750196082, 1.15034938037601]),
        9: np.array([-np.inf, -1.22064034884735, -0.764709673786387,
                    -0.430727299295457, -0.139710298881862, 0.139710298881862,
                    0.430727299295457, 0.764709673786387, 1.22064034884735]),
        10: np.array([-np.inf, -1.2815515655446, -0.841621233572914,
                     -0.524400512708041, -0.2533471031358, 0, 0.2533471031358,
                     0.524400512708041, 0.841621233572914, 1.2815515655446]),
        11: np.array([-np.inf, -1.33517773611894, -0.908457868537385,
                     -0.604585346583237, -0.348755695517045,
                     -0.114185294321428, 0.114185294321428, 0.348755695517045,
                     0.604585346583237, 0.908457868537385, 1.33517773611894]),
        12: np.array([-np.inf, -1.38299412710064, -0.967421566101701,
                     -0.674489750196082, -0.430727299295457,
                     -0.210428394247925, 0, 0.210428394247925,
                     0.430727299295457, 0.674489750196082, 0.967421566101701,
                     1.38299412710064]),
        13: np.array([-np.inf, -1.42607687227285, -1.0200762327862,
                     -0.736315917376129, -0.502402223373355,
                     -0.293381232121193, -0.0965586152896391,
                     0.0965586152896394, 0.293381232121194, 0.502402223373355,
                     0.73631591737613, 1.0200762327862, 1.42607687227285]),
        14: np.array([-np.inf, -1.46523379268552, -1.06757052387814,
                     -0.791638607743375, -0.565948821932863, -0.36610635680057,
                     -0.180012369792705, 0, 0.180012369792705,
                     0.36610635680057, 0.565948821932863, 0.791638607743375,
                     1.06757052387814, 1.46523379268552]),
        15: np.array([-np.inf, -1.50108594604402, -1.11077161663679,
                     -0.841621233572914, -0.622925723210088,
                     -0.430727299295457, -0.2533471031358, -0.0836517339071291,
                     0.0836517339071291, 0.2533471031358, 0.430727299295457,
                     0.622925723210088, 0.841621233572914, 1.11077161663679,
                     1.50108594604402]),
        16: np.array([-np.inf, -1.53412054435255, -1.15034938037601,
                     -0.887146559018876, -0.674489750196082,
                     -0.488776411114669, -0.318639363964375,
                     -0.157310684610171, 0, 0.157310684610171,
                     0.318639363964375, 0.488776411114669, 0.674489750196082,
                     0.887146559018876, 1.15034938037601, 1.53412054435255]),
        17: np.array([-np.inf, -1.5647264713618, -1.18683143275582,
                     -0.928899491647271, -0.721522283982343,
                     -0.541395085129088, -0.377391943828554,
                     -0.223007830940367, -0.0737912738082727,
                     0.0737912738082727, 0.223007830940367, 0.377391943828554,
                     0.541395085129088, 0.721522283982343, 0.928899491647271,
                     1.18683143275582, 1.5647264713618]),
        18: np.array([-np.inf, -1.59321881802305, -1.22064034884735,
                     -0.967421566101701, -0.764709673786387,
                     -0.589455797849779, -0.430727299295457,
                     -0.282216147062508, -0.139710298881862, 0,
                     0.139710298881862, 0.282216147062508, 0.430727299295457,
                     0.589455797849779, 0.764709673786387, 0.967421566101701,
                     1.22064034884735, 1.59321881802305]),
        19: np.array([-np.inf, -1.61985625863827, -1.25211952026522,
                     -1.00314796766253, -0.8045963803603, -0.633640000779701,
                     -0.47950565333095, -0.336038140371823, -0.199201324789267,
                     -0.0660118123758407, 0.0660118123758406,
                     0.199201324789267, 0.336038140371823, 0.47950565333095,
                     0.633640000779701, 0.8045963803603, 1.00314796766253,
                     1.25211952026522, 1.61985625863827]),
        20: np.array([-np.inf, -1.64485362695147, -1.2815515655446,
                     -1.03643338949379, -0.841621233572914, -0.674489750196082,
                     -0.524400512708041, -0.385320466407568, -0.2533471031358,
                     -0.125661346855074, 0, 0.125661346855074, 0.2533471031358,
                     0.385320466407568, 0.524400512708041, 0.674489750196082,
                     0.841621233572914, 1.03643338949379, 1.2815515655446,
                     1.64485362695147]),
        21: np.array([-np.inf, -1.66839119, -1.30917172, -1.06757052, -0.87614285,
                       -0.71244303, -0.56594882, -0.4307273 , -0.30298045, -0.18001237,
                       -0.0597171 ,  0.0597171 ,  0.18001237,  0.30298045,  0.4307273 ,
                        0.56594882,  0.71244303,  0.87614285,  1.06757052,  1.30917172,
                        1.66839119]),
        22: np.array([-np.inf, -1.69062163, -1.33517774, -1.09680356, -0.90845787,
                   -0.74785859, -0.60458535, -0.47278912, -0.3487557 , -0.22988412,
                   -0.11418529,  0,  0.11418529,  0.22988412,  0.3487557 ,
                    0.47278912,  0.60458535,  0.74785859,  0.90845787,  1.09680356,
                    1.33517774,  1.69062163]),
        23: np.array([-np.inf, -1.71167531, -1.35973738, -1.12433823, -0.93881432,
                   -0.78103381, -0.64066689, -0.51193621, -0.39119626, -0.27592106,
                   -0.16421078, -0.05451891,  0.05451891,  0.16421078,  0.27592106,
                    0.39119626,  0.51193621,  0.64066689,  0.78103381,  0.93881432,
                    1.12433823,  1.35973738,  1.71167531]),
        24: np.array([-np.inf, -1.7316644 , -1.38299413, -1.15034938, -0.96742157,
                       -0.8122178 , -0.67448975, -0.54852228, -0.4307273 , -0.31863936,
                       -0.21042839, -0.10463346,  0,  0.10463346,  0.21042839,
                        0.31863936,  0.4307273 ,  0.54852228,  0.67448975,  0.8122178 ,
                        0.96742157,  1.15034938,  1.38299413,  1.7316644 ]),
        25: np.array([-np.inf, -1.75068607, -1.40507156, -1.17498679, -0.99445788,
                   -0.84162123, -0.70630256, -0.58284151, -0.4676988, -0.35845879,
                   -0.2533471, -0.15096922, -0.05015358, 0.05015358, 0.15096922,
                   0.2533471, 0.35845879, 0.4676988, 0.58284151, 0.70630256,
                   0.84162123, 0.99445788, 1.17498679, 1.40507156, 1.75068607]),
        26: np.array([-np.inf, -1.76882504, -1.42607687, -1.1983797, -1.02007623,
                   -0.86942377, -0.73631592, -0.6151411, -0.50240222, -0.3957253,
                   -0.29338123, -0.19402814, -0.09655862, 0, 0.09655862,
                   0.19402814, 0.29338123, 0.3957253, 0.50240222, 0.6151411,
                   0.73631592, 0.86942377, 1.02007623, 1.1983797, 1.42607687,
                   1.76882504])
    }
    return options[a_size]

@njit(parallel = True)
def paa(series, paa_segments):
    """PAA implementation."""
    series_len = len(series)

    # check for the trivial case
    if (series_len == paa_segments):
        return np.copy(series)
    else:
        res = np.zeros(paa_segments)
        # check when we are even
        if (series_len % paa_segments == 0):
            inc = series_len // paa_segments
            for i in range(0, series_len):
                idx = i // inc
                #np.add.at(res, idx, series[i])
                res[idx] = res[idx] + series[i]
            return res / inc
        # and process when we are odd
        else:
            for i in range(0, paa_segments * series_len):
                idx = i // series_len
                pos = i // paa_segments
                #np.add.at(res, idx, series[pos])
                res[idx] = res[idx] + series[pos]
            return res / series_len

@njit
def ts_to_string(series, cuts):
    """A straightforward num-to-string conversion."""
    a_size = len(cuts)
    sax = list()
    for i in range(0, len(series)):
        num = series[i]
        # if teh number below 0, start from the bottom, or else from the top
        if(num >= 0):
            j = a_size - 1
            while ((j > 0) and (cuts[j] >= num)):
                j = j - 1
            sax.append(idx2letter(j))
        else:
            j = 1
            while (j < a_size and cuts[j] <= num):
                j = j + 1
            sax.append(idx2letter(j-1))
    return ''.join(sax)

def sax_transform(arrays, word_length, alphabet_size, alphabet = 'ordinal'):
    ret_arr = np.array([ts_to_string(paa(znorm(ts),word_length),cuts_for_asize(alphabet_size)) for ts in arrays])
    if alphabet == 'latin':
        return ret_arr
    elif alphabet == 'ordinal':
        alpha2num = {'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9,'k':10,'l':11,'m':12,'n':13,'o':14,
                     'p':15,'q':16,'r':17,'s':18,'t':19,'u':20,'v':21,'w':22,'x':23,'y':24,'z':25}
        return np.array([np.array([alpha2num[char] for char in ts]) for ts in ret_arr])
    
    
